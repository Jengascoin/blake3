(self.webpackChunk=self.webpackChunk||[]).push([[792],{792:(e,t,r)=>{"use strict";let n;r.r(t),r.d(t,{BaseHash:()=>y,BaseHashReader:()=>b,BrowserHasher:()=>m,createHash:()=>E,createKeyed:()=>B,defaultHashLength:()=>o,deriveKey:()=>w,hash:()=>p,inputToArray:()=>i,keyedHash:()=>_,maxHashBytes:()=>g,using:()=>v});const s=()=>{if(!n)throw new Error("BLAKE3 webassembly not loaded. Please import the module via `blake3/browser` or `blake3/browser-async`");return n};var a=r(267);const o=32,i=e=>e instanceof Uint8Array?e:new Uint8Array(e),h=new TextDecoder,d={base64:e=>btoa(String.fromCharCode(...e)),hex:e=>{let t="";for(const r of e)r<16&&(t+="0"),t+=r.toString(16);return t},utf8:e=>h.decode(e)},c=e=>{const t=d[e];if(!t)throw new Error(`Unknown encoding ${e}`);return t};class l extends Uint8Array{equals(e){if(!(e instanceof Uint8Array))return!1;if(e.length!==this.length)return!1;let t=0;for(let r=0;r<this.length;r++)t|=this[r]^e[r];return 0===t}toString(e="hex"){return c(e)(this)}}const u=new TextEncoder,f=e=>i("string"==typeof e?u.encode(e):e);function p(e,{length:t=o}={}){const r=new l(t);return s().hash(f(e),r),r}function w(e,t,{length:r=o}={}){const n=s().create_derive(e);n.update(f(t));const a=new l(r);return n.digest(a),a}function _(e,t,{length:r=o}={}){if(32!==e.length)throw new Error(`key provided to keyedHash must be 32 bytes, got ${e.length}`);const n=s().create_keyed(e);n.update(f(t));const a=new l(r);return n.digest(a),a}const g=BigInt("18446744073709551615");class b{constructor(e){this.pos=BigInt(0),this.reader=e}get position(){return this.pos}set position(e){var t;if("bigint"!=typeof e)throw new Error(`Got a ${typeof e} set in to reader.position, expected a bigint`);this.boundsCheck(e),this.pos=e,null===(t=this.reader)||void 0===t||t.set_position(e)}readInto(e){if(!this.reader)throw new Error("Cannot read from a hash after it was disposed");const t=this.pos+BigInt(e.length);this.boundsCheck(t),this.reader.fill(e),this.position=t}read(e){const t=this.alloc(e);return this.readInto(t),t}dispose(){var e,t;null===(t=null===(e=this.reader)||void 0===e?void 0:e.free)||void 0===t||t.call(e),this.reader=void 0}boundsCheck(e){if(e>g)throw new RangeError(`Cannot read past ${g} bytes in BLAKE3 hashes`);if(e<BigInt(0))throw new RangeError("Cannot read to a negative position")}}class y{constructor(e,t,r){this.alloc=t,this.getReader=r,this.hash=e}update(e){if(!this.hash)throw new Error("Cannot continue updating hashing after dispose() has been called");return this.hash.update(i(e)),this}digest({length:e=o,dispose:t=!0}={}){if(!this.hash)throw new Error("Cannot call digest() after dipose() has been called");const r=this.alloc(e);return this.hash.digest(r),t&&this.dispose(),r}reader({dispose:e=!0}={}){if(!this.hash)throw new Error("Cannot call reader() after dipose() has been called");const t=this.getReader(this.hash.reader());return e&&this.dispose(),t}dispose(){var e;null===(e=this.hash)||void 0===e||e.free(),this.hash=void 0}}const v=(e,t)=>{let r;try{r=t(e)}catch(t){throw e.dispose(),t}return"object"==typeof(n=r)&&n&&"then"in n?r.then((t=>(e.dispose(),t)),(t=>{throw e.dispose(),t})):(e.dispose(),r);var n};class k extends b{toString(e="hex"){return this.toArray().toString(e)}toArray(){return this.position=BigInt(0),this.read(o)}alloc(e){return new l(e)}}class m extends y{update(e){return super.update(f(e))}digest(e,t){let r,n;e&&"object"==typeof e?(r=e,n=void 0):(r=t,n=e);const s=super.digest(r);return n?c(n)(s):s}}const E=()=>new m(s().create_hasher(),(e=>new l(e)),(e=>new k(e))),B=e=>new m(s().create_keyed(e),(e=>new l(e)),(e=>new k(e)));n=a},267:(e,t,r)=>{"use strict";r.r(t),r.d(t,{hash:()=>d,create_hasher:()=>c,create_keyed:()=>l,create_derive:()=>p,Blake3Hash:()=>g,HashReader:()=>b,__wbindgen_throw:()=>y});var n=r(313);let s=new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0});s.decode();let a=null;function o(){return null!==a&&a.buffer===n.memory.buffer||(a=new Uint8Array(n.memory.buffer)),a}let i=0;function h(e,t){const r=t(1*e.length);return o().set(e,r/1),i=e.length,r}function d(e,t){try{var r=h(e,n.__wbindgen_malloc),s=i,a=h(t,n.__wbindgen_malloc),d=i;n.hash(r,s,a,d)}finally{t.set(o().subarray(a/1,a/1+d)),n.__wbindgen_free(a,1*d)}}function c(){var e=n.create_hasher();return g.__wrap(e)}function l(e){var t=h(e,n.__wbindgen_malloc),r=i,s=n.create_keyed(t,r);return g.__wrap(s)}let u=new TextEncoder("utf-8");const f="function"==typeof u.encodeInto?function(e,t){return u.encodeInto(e,t)}:function(e,t){const r=u.encode(e);return t.set(r),{read:e.length,written:r.length}};function p(e){var t=function(e,t,r){if(void 0===r){const r=u.encode(e),n=t(r.length);return o().subarray(n,n+r.length).set(r),i=r.length,n}let n=e.length,s=t(n);const a=o();let h=0;for(;h<n;h++){const t=e.charCodeAt(h);if(t>127)break;a[s+h]=t}if(h!==n){0!==h&&(e=e.slice(h)),s=r(s,n,n=h+3*e.length);const t=o().subarray(s+h,s+n);h+=f(e,t).written}return i=h,s}(e,n.__wbindgen_malloc,n.__wbindgen_realloc),r=i,s=n.create_derive(t,r);return g.__wrap(s)}const w=new Uint32Array(2),_=new BigUint64Array(w.buffer);class g{static __wrap(e){const t=Object.create(g.prototype);return t.ptr=e,t}free(){const e=this.ptr;this.ptr=0,n.__wbg_blake3hash_free(e)}reader(){var e=n.blake3hash_reader(this.ptr);return b.__wrap(e)}update(e){var t=h(e,n.__wbindgen_malloc),r=i;n.blake3hash_update(this.ptr,t,r)}digest(e){try{var t=h(e,n.__wbindgen_malloc),r=i;n.blake3hash_digest(this.ptr,t,r)}finally{e.set(o().subarray(t/1,t/1+r)),n.__wbindgen_free(t,1*r)}}}class b{static __wrap(e){const t=Object.create(b.prototype);return t.ptr=e,t}free(){const e=this.ptr;this.ptr=0,n.__wbg_hashreader_free(e)}fill(e){try{var t=h(e,n.__wbindgen_malloc),r=i;n.hashreader_fill(this.ptr,t,r)}finally{e.set(o().subarray(t/1,t/1+r)),n.__wbindgen_free(t,1*r)}}set_position(e){_[0]=e;const t=w[0],r=w[1];n.hashreader_set_position(this.ptr,t,r)}}const y=function(e,t){throw new Error((r=e,n=t,s.decode(o().subarray(r,r+n))));var r,n}},313:(e,t,r)=>{"use strict";var n=r.w[e.id];e.exports=n,r(267),n[""]()}}]);